# jvm的一些问题

## 1. jvm由哪些部分组成
- 类加载器，在jvm启动时或者类运行时将需要的class文件加载到jvm中
- 执行引擎，执行引擎的任务时负责执行class文件中包含的字节码指令，相当于实际机器的cpu
- 内存区，将内存划分成若干个区模拟实际机器上的存储，记录和调度功能模块，如实际机器上的各种功能的寄存器或者pc指针的记录器等
- 本地方法调用，调用c或者c++实现本地方法的代码返回结果

## 2. 类加载器  
- 类加载器是用来加载java类到jvm中的，一般来说，jvm虚拟机使用java类的方式如下：java源程序在经过java编译器编译之后被转换成java字节码文件(.class)文件。类加载器负责读取java字节代码，并转换成java.lang.Class类的一个实例.每个这样的实例用来表示一个java类。通过此实例的newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂。

## 3. jvm如何判断两个java类是相同的  
- jvm不仅要看类的全名是否相同，还要看加载此类的类加载器是否一致。只有两者都一致，才认为两个类相同。即使是同一个字节代码，被不同的类加载器加载之后所得到的类，也是不同的。如将相同.class文件不同类加载器加载的类实例转化，会抛出异常ClassCastException.

## 4. 类加载器如何加载class文件的
- 加载
- 连接
    - 验证：确保被加载的类的正确性
        - 格式校验
        - 元数据校验
        - 字节码验证
        - 符号引用验证
    - 准备：为类的静态变量分配内存
    - 解析：把类中的符号引用转换为直接引用
- 初始化
- 结束生命周期

## 5. 双亲委派模型  
- 类的加载过程通过双亲委派机制，这种机制能更好的保证java平台的安全性

- 类加载器是具有层次结构的，Bootstrap是所有类加载器的父类。除了要求顶层的Bootstrap class loader启动类加载器外，其余的类加载器都有自己的父类加载器，子类加载器和父类加载器不是以继承的关系来实现的，而是通过组合关系来复用父加载器的的代码。每个类加载器都有自己的命名空间(由该加载器及所有父类加载器所加载的类组成，在同一个命名空间中，不会出现类的完整名字(包括类的包名)相同的两个类，在不同的命名空间中，有可能会出现类的完整名字(包括类的包名)相同的两个类)

- 双亲委派模型的工作过程
    - 当前ClassLoader首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以自己返回了
    - 当前classLoader的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后为头父类的父类去加载，一直到Bootstrap ClassLoader。当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将去放入它自己的缓存中，以便下次有加载请求的时候直接返回

- 为什么这样设计
    - 主要是为了安全性，避免用户自己编写的类动态替换java的核心类，比如Sting，同时也避免了重复加载，因为jvm中区分不同的类，不仅仅时根据类名，相同的class文件被不同的ClassLoader加载就是不同的两个类，如果相互转型的话会报错。
