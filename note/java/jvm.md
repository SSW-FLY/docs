# jvm的一些问题

## 1. jvm由哪些部分组成
- 类加载器，在jvm启动时或者类运行时将需要的class文件加载到jvm中
- 执行引擎，执行引擎的任务时负责执行class文件中包含的字节码指令，相当于实际机器的cpu
- 内存区，将内存划分成若干个区模拟实际机器上的存储，记录和调度功能模块，如实际机器上的各种功能的寄存器或者pc指针的记录器等
- 本地方法调用，调用c或者c++实现本地方法的代码返回结果

## 2. 类加载器  
- 类加载器是用来加载java类到jvm中的，一般来说，jvm虚拟机使用java类的方式如下：java源程序在经过java编译器编译之后被转换成java字节码文件(.class)文件。类加载器负责读取java字节代码，并转换成java.lang.Class类的一个实例.每个这样的实例用来表示一个java类。通过此实例的newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂。

## 3. jvm如何判断两个java类是相同的  
- jvm不仅要看类的全名是否相同，还要看加载此类的类加载器是否一致。只有两者都一致，才认为两个类相同。即使是同一个字节代码，被不同的类加载器加载之后所得到的类，也是不同的。如将相同.class文件不同类加载器加载的类实例转化，会抛出异常ClassCastException.

## 4. 类加载器如何加载class文件的
- 加载
- 连接
    - 验证：确保被加载的类的正确性
        - 格式校验
        - 元数据校验
        - 字节码验证
        - 符号引用验证
    - 准备：为类的静态变量分配内存
    - 解析：把类中的符号引用转换为直接引用
- 初始化
- 结束生命周期

## 5. 双亲委派模型  
- 类的加载过程通过双亲委派机制，这种机制能更好的保证java平台的安全性

- 类加载器是具有层次结构的，Bootstrap是所有类加载器的父类。除了要求顶层的Bootstrap class loader启动类加载器外，其余的类加载器都有自己的父类加载器，子类加载器和父类加载器不是以继承的关系来实现的，而是通过组合关系来复用父加载器的的代码。每个类加载器都有自己的命名空间(由该加载器及所有父类加载器所加载的类组成，在同一个命名空间中，不会出现类的完整名字(包括类的包名)相同的两个类，在不同的命名空间中，有可能会出现类的完整名字(包括类的包名)相同的两个类)

- 双亲委派模型的工作过程
    - 当前ClassLoader首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以自己返回了
    - 当前classLoader的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后为头父类的父类去加载，一直到Bootstrap ClassLoader。当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将去放入它自己的缓存中，以便下次有加载请求的时候直接返回

- 为什么这样设计
    - 主要是为了安全性，避免用户自己编写的类动态替换java的核心类，比如Sting，同时也避免了重复加载，因为jvm中区分不同的类，不仅仅时根据类名，相同的class文件被不同的ClassLoader加载就是不同的两个类，如果相互转型的话会报错。


## 6.jvm的内存划分

- 1. 方法区(线程共享)：各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然java虚拟机规范把方法区描述为堆的一个逻辑部分，但是他却有一个别名叫Non-Heap，目的应该是与java堆区分开。
    - 运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。

- 2. 堆内存(线程共享)：所有线程共享的一块区域，垃圾收集器管理的主要区域。目前主要的垃圾回收算法都是分代收集算法，所以java堆中还可以细分为：新生代和老年代，在细致一点的有Eden空间、From Survivor空间、To Survivor空间等，默认情况下新生代按照8：1：1的比例来分配。根据java虚拟机规范的规定，java对可以处于物理上不连续的内存空间，只要逻辑上连续即可。

- 3. 程序计数器：java线程私有，类似操作系统里的PC计数器，它可以看作是当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，这个计数器则为空。这个内存区域是唯一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

- 4. 虚拟机栈(栈内存)：java线程私有，虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息，每个方法调用都以为着一个栈帧在虚拟机栈中入栈到出栈的过程。

- 5. 本地方法栈：和java虚拟机栈的作用类似，区别是该区域为jvm提供使用native方法的服务。

## 对象分配规则
- 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC

- 大对象直接进入老年代(大对象是指需要大量连续内存空间的对象)。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝(新生代采用复制算法收集内存)。

- 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。

- 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。

- 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC，如果false则进行Full GC